/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2012-2013, 2015-2016,
 * Technische Universitaet Dresden, Germany
 *
 * Copyright (c) 2024,
 * Forschungszentrum Juelich GmbH, Germany
 *
 * This software may be modified and distributed under the terms of
 * a BSD-style license.  See the COPYING file in the package base
 * directory for details.
 */

/**
 * @file
 *
 * @brief Contains definition for
 * region descriptor struct for GCC and LLVM plugin
 */


#ifndef SCOREP_COMPILER_PLUGIN_H
#define SCOREP_COMPILER_PLUGIN_H

#include <stdint.h>
#include <scorep/SCOREP_PublicTypes.h>

typedef struct {
    uint32_t *handle;
    const char *name;
    const char *canonical_name;
    const char *file;
    int begin_lno;
    int end_lno;
    unsigned flags; /* unused */
}
    __attribute__(( aligned( 64 ))) scorep_compiler_region_description;

void scorep_compiler_plugin_register_region(const scorep_compiler_region_description *region_descr);

#if HAVE(XRAY_PLUGIN_SUPPORT)
// Make sure to #include <config-xray-plugin.h> where this is expected to be included. Can't include here, or it clashes
// with config-backend in other files as they are autogenerated by autoconf and don't have include guards
    void scorep_plugin_enter_region( SCOREP_RegionHandle regionHandle );
    void scorep_plugin_exit_region( SCOREP_RegionHandle regionHandle );
#endif

#if HAVE(XRAY_PLUGIN_SUPPORT) || HAVE(LLVM_PLUGIN_SUPPORT)
#include <fnmatch.h>
#include <string.h>


/**
 * Checks whether a function should be instrumented or if the default filter advises
 * to filter it out (based on the llvm plugin default filter)
 * @author llvm plugin
 * @param demangledName Demangled Name of function
 * @param mangledName Mangled name of function
 * @return true if function should be instrumented, false if it should be filtered
 */
bool mayInstrument(const char *demangledName, const char *mangledName) {
// Check against function names we NEVER want to instrument
    return (strncmp(demangledName, "POMP", 4) != 0) &&
    (strncmp(demangledName, "Pomp", 4) != 0) &&
           (strncmp(demangledName, "pomp", 4) != 0) &&
           (strncmp(demangledName, "SCOREP_", 7) != 0) &&
           (strncmp(demangledName, "scorep_", 7) != 0) &&
           (strncmp(demangledName, "OTF2_", 5) != 0) &&
           (strncmp(demangledName, "otf2_", 5) != 0) &&
           (strncmp(demangledName, "cube_", 5) != 0) &&
           (strncmp(demangledName, "cubew_", 6) != 0) &&
           (strncmp(demangledName, ".omp", 4) != 0) &&
           (!strstr(demangledName, "DIR.OMP.")) &&
           (!strstr(demangledName, ".extracted")) &&
           #if HAVE(SCOREP_COMPILER_CC_INTEL_ONEAPI) || HAVE(SCOREP_COMPILER_CXX_INTEL_ONEAPI) || HAVE(SCOREP_COMPILER_FC_INTEL_ONEAPI)
           ( !strstr( demangledName, "_tree_reduce_" ) ) &&
           #endif  /* Intel oneAPI compiler */
           (strncmp(demangledName, "..omp", 5) != 0) &&
           (strncmp(demangledName, "__omp", 5) != 0) &&
           (strncmp(demangledName, "..acc", 5) != 0) &&
           (strncmp(demangledName, "virtual thunk", 13) != 0) &&
           (strncmp(demangledName, "non-virtual thunk", 17) != 0) &&
           (!strstr(demangledName, "Kokkos::Tools")) &&
           (!strstr(demangledName, "Kokkos::Profiling")) &&
           (!strstr(demangledName, "6Kokkos5Tools")) &&
           (!strstr(demangledName, "6Kokkos9Profiling")) &&

           // Newly added filters needed for LLVM plugin functions
           // Basic C++
           (!strstr(demangledName, "_GLOBAL__")) &&
           (!strstr(demangledName, "__gnu_cxx::")) &&
           (!strstr(demangledName, "__cxx_")) &&
           (!strstr(demangledName, "std::")) &&

           // OpenMP
           (fnmatch("__clang_*", demangledName, 0) != 0) &&
           (fnmatch("omp*$omp*$*", demangledName, 0) != 0) &&
           (fnmatch("*.omp_outlined*", mangledName, 0) != 0) &&
           (fnmatch("*.omp_outlined_debug__*", mangledName, 0) != 0) &&
           (!strstr(demangledName, "_omp_")) &&
           (!strstr(demangledName, "_omp$")) &&
           (!strstr(demangledName, "__kmpc")) &&
           (strncmp(demangledName, "ompx::", 6) != 0) &&
           (strncmp(demangledName, "__keep_alive", 10) != 0) &&
           (strncmp(demangledName, "__assert_fail", 13) != 0) &&
           (!strstr(demangledName, "__internal_trig_")) &&
           (!strstr(demangledName, "thread-local wrapper routine")) &&
           (!strstr(demangledName, "(anonymous namespace)::invokeMicrotask")) &&
           (strncmp(demangledName, ".red_init.", 10) != 0) &&
           (strncmp(demangledName, ".red_comb.", 10) != 0) &&
           // MPI
           (strncmp(demangledName, "MPI::", 5) != 0)&&
           // CUDA
           (!strstr(demangledName, "__device_stub__")) &&
           (fnmatch("__cuda*", demangledName, 0) != 0) &&
           (fnmatch("_*_nv_*", demangledName, 0) != 0) &&
           (fnmatch("__sti_*cuda*", demangledName, 0) != 0) &&
           // HIP
           (fnmatch("__hip*", demangledName, 0) != 0);
}
#endif

#endif /* SCOREP_COMPILER_PLUGIN_H */
