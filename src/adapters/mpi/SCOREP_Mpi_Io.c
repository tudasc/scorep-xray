/*
 * This file is part of the Score-P software (http://www.score-p.org)
 *
 * Copyright (c) 2009-2012,
 *    RWTH Aachen University, Germany
 *    Gesellschaft fuer numerische Simulation mbH Braunschweig, Germany
 *    Technische Universitaet Dresden, Germany
 *    University of Oregon, Eugene, USA
 *    Forschungszentrum Juelich GmbH, Germany
 *    German Research School for Simulation Sciences GmbH, Juelich/Aachen, Germany
 *    Technische Universitaet Muenchen, Germany
 *
 * See the COPYING file in the package base directory for details.
 *
 */

/****************************************************************************
**  SCALASCA    http://www.scalasca.org/                                   **
*****************************************************************************
**  Copyright (c) 1998-2011                                                **
**  Forschungszentrum Juelich GmbH, Juelich Supercomputing Centre          **
**                                                                         **
**  Copyright (c) 2010-2011                                                **
**  German Research School for Simulation Sciences GmbH,                   **
**  Laboratory for Parallel Programming                                    **
**                                                                         **
**  Copyright (c) 2003-2008                                                **
**  University of Tennessee, Innovative Computing Laboratory               **
**                                                                         **
**  See the file COPYRIGHT in the package base directory for details       **
****************************************************************************/


/**
 * @file  SCOREP_Mpi_Io.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     alpha
 * @ingroup    MPI_Wrapper
 *
 * @brief C interface wrappers for parallel I/O
 */

#include <config.h>
#include "SCOREP_Mpi.h"

/**
 * @name C wrappers for administrative functions
 * @{
 */

#if HAVE( DECL_PMPI_FILE_CLOSE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_close )
/**
 * Measurement wrapper for MPI_File_close
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_close( MPI_File* fh )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CLOSE ] );

        return_val = PMPI_File_close( fh );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CLOSE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_close( fh );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_DELETE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_delete )
/**
 * Measurement wrapper for MPI_File_delete
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_delete( char* filename, MPI_Info info )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_DELETE ] );

        return_val = PMPI_File_delete( filename, info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_DELETE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_delete( filename, info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_AMODE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_amode )
/**
 * Measurement wrapper for MPI_File_get_amode
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_amode( MPI_File fh, int* amode )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_AMODE ] );

        return_val = PMPI_File_get_amode( fh, amode );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_AMODE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_amode( fh, amode );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_ATOMICITY ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_atomicity )
/**
 * Measurement wrapper for MPI_File_get_atomicity
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_atomicity( MPI_File fh, int* flag )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_ATOMICITY ] );

        return_val = PMPI_File_get_atomicity( fh, flag );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_ATOMICITY ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_atomicity( fh, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_BYTE_OFFSET ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_byte_offset )
/**
 * Measurement wrapper for MPI_File_get_byte_offset
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_byte_offset( MPI_File fh, MPI_Offset offset, MPI_Offset* disp )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_BYTE_OFFSET ] );

        return_val = PMPI_File_get_byte_offset( fh, offset, disp );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_BYTE_OFFSET ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_byte_offset( fh, offset, disp );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_GROUP ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_group )
/**
 * Measurement wrapper for MPI_File_get_group
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_group( MPI_File fh, MPI_Group* group )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_GROUP ] );

        return_val = PMPI_File_get_group( fh, group );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_GROUP ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_group( fh, group );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_INFO ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_info )
/**
 * Measurement wrapper for MPI_File_get_info
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_info( MPI_File fh, MPI_Info* info_used )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_INFO ] );

        return_val = PMPI_File_get_info( fh, info_used );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_INFO ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_info( fh, info_used );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_POSITION ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_position )
/**
 * Measurement wrapper for MPI_File_get_position
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_position( MPI_File fh, MPI_Offset* offset )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_POSITION ] );

        return_val = PMPI_File_get_position( fh, offset );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_POSITION ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_position( fh, offset );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_POSITION_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_position_shared )
/**
 * Measurement wrapper for MPI_File_get_position_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_position_shared( MPI_File fh, MPI_Offset* offset )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_POSITION_SHARED ] );

        return_val = PMPI_File_get_position_shared( fh, offset );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_POSITION_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_position_shared( fh, offset );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_SIZE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_size )
/**
 * Measurement wrapper for MPI_File_get_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_size( MPI_File fh, MPI_Offset* size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_SIZE ] );

        return_val = PMPI_File_get_size( fh, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_size( fh, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_TYPE_EXTENT ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_type_extent )
/**
 * Measurement wrapper for MPI_File_get_type_extent
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_type_extent( MPI_File fh, MPI_Datatype datatype, MPI_Aint* extent )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_TYPE_EXTENT ] );

        return_val = PMPI_File_get_type_extent( fh, datatype, extent );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_TYPE_EXTENT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_type_extent( fh, datatype, extent );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_VIEW ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_get_view )
/**
 * Measurement wrapper for MPI_File_get_view
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_view( MPI_File fh, MPI_Offset* disp, MPI_Datatype* etype, MPI_Datatype* filetype, char* datarep )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_VIEW ] );

        return_val = PMPI_File_get_view( fh, disp, etype, filetype, datarep );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_VIEW ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_view( fh, disp, etype, filetype, datarep );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_OPEN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_open )
/**
 * Measurement wrapper for MPI_File_open
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_open( MPI_Comm comm, char* filename, int amode, MPI_Info info, MPI_File* fh )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_OPEN ] );

        return_val = PMPI_File_open( comm, filename, amode, info, fh );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_OPEN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_open( comm, filename, amode, info, fh );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SEEK ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_seek )
/**
 * Measurement wrapper for MPI_File_seek
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_seek( MPI_File fh, MPI_Offset offset, int whence )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SEEK ] );

        return_val = PMPI_File_seek( fh, offset, whence );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SEEK ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_seek( fh, offset, whence );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SEEK_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_seek_shared )
/**
 * Measurement wrapper for MPI_File_seek_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_seek_shared( MPI_File fh, MPI_Offset offset, int whence )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SEEK_SHARED ] );

        return_val = PMPI_File_seek_shared( fh, offset, whence );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SEEK_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_seek_shared( fh, offset, whence );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SET_ATOMICITY ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_set_atomicity )
/**
 * Measurement wrapper for MPI_File_set_atomicity
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_set_atomicity( MPI_File fh, int flag )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_ATOMICITY ] );

        return_val = PMPI_File_set_atomicity( fh, flag );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_ATOMICITY ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_set_atomicity( fh, flag );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SET_INFO ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_set_info )
/**
 * Measurement wrapper for MPI_File_set_info
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_set_info( MPI_File fh, MPI_Info info )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_INFO ] );

        return_val = PMPI_File_set_info( fh, info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_INFO ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_set_info( fh, info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SET_SIZE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_set_size )
/**
 * Measurement wrapper for MPI_File_set_size
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_set_size( MPI_File fh, MPI_Offset size )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_SIZE ] );

        return_val = PMPI_File_set_size( fh, size );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_SIZE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_set_size( fh, size );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SET_VIEW ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_set_view )
/**
 * Measurement wrapper for MPI_File_set_view
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_set_view( MPI_File fh, MPI_Offset disp, MPI_Datatype etype, MPI_Datatype filetype, char* datarep, MPI_Info info )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_VIEW ] );

        return_val = PMPI_File_set_view( fh, disp, etype, filetype, datarep, info );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_VIEW ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_set_view( fh, disp, etype, filetype, datarep, info );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SYNC ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_sync )
/**
 * Measurement wrapper for MPI_File_sync
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_sync( MPI_File fh )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SYNC ] );

        return_val = PMPI_File_sync( fh );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SYNC ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_sync( fh );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_REGISTER_DATAREP ) && !defined( SCOREP_MPI_NO_IO ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( MPI_Register_datarep )
/**
 * Measurement wrapper for MPI_Register_datarep
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_Register_datarep( char* datarep, MPI_Datarep_conversion_function* read_conversion_fn, MPI_Datarep_conversion_function* write_conversion_fn, MPI_Datarep_extent_function* dtype_file_extent_fn, void* extra_state )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_REGISTER_DATAREP ] );

        return_val = PMPI_Register_datarep( datarep, read_conversion_fn, write_conversion_fn, dtype_file_extent_fn, extra_state );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_REGISTER_DATAREP ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_Register_datarep( datarep, read_conversion_fn, write_conversion_fn, dtype_file_extent_fn, extra_state );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for access functions
 * @{
 */

/* MPI Implementation which use ROMIO can have no general support for MPI_Requests
   in asynchronous file IO operations. This leads to a different signature and
   thus to compiler errors. To avoid compilation errors, the asynchronous file
   IO functions are not wrapped if ROMIO is used and they support no general
   MPI_Requests.
 */
#if !defined( ROMIO_VERSION ) || defined( MPIO_USES_MPI_REQUEST )

#if HAVE( DECL_PMPI_FILE_IREAD ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iread )
/**
 * Measurement wrapper for MPI_File_iread
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iread( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD ] );

        return_val = PMPI_File_iread( fh, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iread( fh, buf, count, datatype, request );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_IREAD_AT ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iread_at )
/**
 * Measurement wrapper for MPI_File_iread_at
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iread_at( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD_AT ] );

        return_val = PMPI_File_iread_at( fh, offset, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD_AT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iread_at( fh, offset, buf, count, datatype, request );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_IREAD_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iread_shared )
/**
 * Measurement wrapper for MPI_File_iread_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iread_shared( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD_SHARED ] );

        return_val = PMPI_File_iread_shared( fh, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IREAD_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iread_shared( fh, buf, count, datatype, request );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_IWRITE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iwrite )
/**
 * Measurement wrapper for MPI_File_iwrite
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iwrite( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE ] );

        return_val = PMPI_File_iwrite( fh, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iwrite( fh, buf, count, datatype, request );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_IWRITE_AT ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iwrite_at )
/**
 * Measurement wrapper for MPI_File_iwrite_at
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iwrite_at( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE_AT ] );

        return_val = PMPI_File_iwrite_at( fh, offset, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE_AT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iwrite_at( fh, offset, buf, count, datatype, request );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_IWRITE_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_iwrite_shared )
/**
 * Measurement wrapper for MPI_File_iwrite_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_iwrite_shared( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Request* request )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE_SHARED ] );

        return_val = PMPI_File_iwrite_shared( fh, buf, count, datatype, request );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_IWRITE_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_iwrite_shared( fh, buf, count, datatype, request );
    }

    return return_val;
}
#endif


#endif /* !defined(ROMIO_VERSION) || defined(MPIO_USES_MPI_REQUEST) */

#if HAVE( DECL_PMPI_FILE_READ ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read )
/**
 * Measurement wrapper for MPI_File_read
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ ] );

        return_val = PMPI_File_read( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ALL ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_all )
/**
 * Measurement wrapper for MPI_File_read_all
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_all( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL ] );

        return_val = PMPI_File_read_all( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_all( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ALL_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_all_begin )
/**
 * Measurement wrapper for MPI_File_read_all_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_all_begin( MPI_File fh, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL_BEGIN ] );

        return_val = PMPI_File_read_all_begin( fh, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_all_begin( fh, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ALL_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_all_end )
/**
 * Measurement wrapper for MPI_File_read_all_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_all_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL_END ] );

        return_val = PMPI_File_read_all_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ALL_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_all_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_AT ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_at )
/**
 * Measurement wrapper for MPI_File_read_at
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_at( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT ] );

        return_val = PMPI_File_read_at( fh, offset, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_at( fh, offset, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_AT_ALL ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_at_all )
/**
 * Measurement wrapper for MPI_File_read_at_all
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_at_all( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL ] );

        return_val = PMPI_File_read_at_all( fh, offset, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_at_all( fh, offset, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_AT_ALL_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_at_all_begin )
/**
 * Measurement wrapper for MPI_File_read_at_all_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_at_all_begin( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL_BEGIN ] );

        return_val = PMPI_File_read_at_all_begin( fh, offset, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_at_all_begin( fh, offset, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_AT_ALL_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_at_all_end )
/**
 * Measurement wrapper for MPI_File_read_at_all_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_at_all_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL_END ] );

        return_val = PMPI_File_read_at_all_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_AT_ALL_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_at_all_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ORDERED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_ordered )
/**
 * Measurement wrapper for MPI_File_read_ordered
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_ordered( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED ] );

        return_val = PMPI_File_read_ordered( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_ordered( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ORDERED_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_ordered_begin )
/**
 * Measurement wrapper for MPI_File_read_ordered_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_ordered_begin( MPI_File fh, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED_BEGIN ] );

        return_val = PMPI_File_read_ordered_begin( fh, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_ordered_begin( fh, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_ORDERED_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_ordered_end )
/**
 * Measurement wrapper for MPI_File_read_ordered_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_ordered_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED_END ] );

        return_val = PMPI_File_read_ordered_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_ORDERED_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_ordered_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_READ_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_read_shared )
/**
 * Measurement wrapper for MPI_File_read_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_read_shared( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_SHARED ] );

        return_val = PMPI_File_read_shared( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_READ_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_read_shared( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write )
/**
 * Measurement wrapper for MPI_File_write
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE ] );

        return_val = PMPI_File_write( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ALL ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_all )
/**
 * Measurement wrapper for MPI_File_write_all
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_all( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL ] );

        return_val = PMPI_File_write_all( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_all( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ALL_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_all_begin )
/**
 * Measurement wrapper for MPI_File_write_all_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_all_begin( MPI_File fh, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL_BEGIN ] );

        return_val = PMPI_File_write_all_begin( fh, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_all_begin( fh, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ALL_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_all_end )
/**
 * Measurement wrapper for MPI_File_write_all_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_all_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL_END ] );

        return_val = PMPI_File_write_all_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ALL_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_all_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_AT ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_at )
/**
 * Measurement wrapper for MPI_File_write_at
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_at( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT ] );

        return_val = PMPI_File_write_at( fh, offset, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_at( fh, offset, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_AT_ALL ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_at_all )
/**
 * Measurement wrapper for MPI_File_write_at_all
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_at_all( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL ] );

        return_val = PMPI_File_write_at_all( fh, offset, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_at_all( fh, offset, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_AT_ALL_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_at_all_begin )
/**
 * Measurement wrapper for MPI_File_write_at_all_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_at_all_begin( MPI_File fh, MPI_Offset offset, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL_BEGIN ] );

        return_val = PMPI_File_write_at_all_begin( fh, offset, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_at_all_begin( fh, offset, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_AT_ALL_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_at_all_end )
/**
 * Measurement wrapper for MPI_File_write_at_all_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_at_all_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL_END ] );

        return_val = PMPI_File_write_at_all_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_AT_ALL_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_at_all_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ORDERED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_ordered )
/**
 * Measurement wrapper for MPI_File_write_ordered
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_ordered( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED ] );

        return_val = PMPI_File_write_ordered( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_ordered( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ORDERED_BEGIN ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_ordered_begin )
/**
 * Measurement wrapper for MPI_File_write_ordered_begin
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_ordered_begin( MPI_File fh, void* buf, int count, MPI_Datatype datatype )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED_BEGIN ] );

        return_val = PMPI_File_write_ordered_begin( fh, buf, count, datatype );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED_BEGIN ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_ordered_begin( fh, buf, count, datatype );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_ORDERED_END ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_ordered_end )
/**
 * Measurement wrapper for MPI_File_write_ordered_end
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_ordered_end( MPI_File fh, void* buf, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED_END ] );

        return_val = PMPI_File_write_ordered_end( fh, buf, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_ORDERED_END ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_ordered_end( fh, buf, status );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_WRITE_SHARED ) && !defined( SCOREP_MPI_NO_IO ) && !defined( MPI_File_write_shared )
/**
 * Measurement wrapper for MPI_File_write_shared
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_write_shared( MPI_File fh, void* buf, int count, MPI_Datatype datatype, MPI_Status* status )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_SHARED ] );

        return_val = PMPI_File_write_shared( fh, buf, count, datatype, status );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_WRITE_SHARED ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_write_shared( fh, buf, count, datatype, status );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name C wrappers for error handling functions
 * @{
 */

#if HAVE( DECL_PMPI_FILE_CALL_ERRHANDLER ) && !defined( SCOREP_MPI_NO_IO ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_ERR ) && !defined( MPI_File_call_errhandler )
/**
 * Measurement wrapper for MPI_File_call_errhandler
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_call_errhandler( MPI_File fh, int errorcode )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO_ERR ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CALL_ERRHANDLER ] );

        return_val = PMPI_File_call_errhandler( fh, errorcode );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CALL_ERRHANDLER ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_call_errhandler( fh, errorcode );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_CREATE_ERRHANDLER ) && !defined( SCOREP_MPI_NO_IO ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_ERR ) && !defined( MPI_File_create_errhandler )
/**
 * Measurement wrapper for MPI_File_create_errhandler
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_create_errhandler( MPI_File_errhandler_fn* function, MPI_Errhandler* errhandler )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO_ERR ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CREATE_ERRHANDLER ] );

        return_val = PMPI_File_create_errhandler( function, errhandler );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_CREATE_ERRHANDLER ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_create_errhandler( function, errhandler );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_GET_ERRHANDLER ) && !defined( SCOREP_MPI_NO_IO ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_ERR ) && !defined( MPI_File_get_errhandler )
/**
 * Measurement wrapper for MPI_File_get_errhandler
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_get_errhandler( MPI_File file, MPI_Errhandler* errhandler )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO_ERR ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_ERRHANDLER ] );

        return_val = PMPI_File_get_errhandler( file, errhandler );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_GET_ERRHANDLER ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_get_errhandler( file, errhandler );
    }

    return return_val;
}
#endif

#if HAVE( DECL_PMPI_FILE_SET_ERRHANDLER ) && !defined( SCOREP_MPI_NO_IO ) && !defined( SCOREP_MPI_NO_EXTRA ) && !defined( SCOREP_MPI_NO_ERR ) && !defined( MPI_File_set_errhandler )
/**
 * Measurement wrapper for MPI_File_set_errhandler
 * @note Auto-generated by wrapgen from template: SCOREP_Mpi_Std.w
 * @note C interface
 * @note Introduced with MPI-2
 * @ingroup io_err
 * Triggers an enter and exit event.
 * It wraps the me) call with enter and exit events.
 */
int
MPI_File_set_errhandler( MPI_File file, MPI_Errhandler errhandler )
{
    int return_val;

    if ( SCOREP_MPI_IS_EVENT_GEN_ON_FOR( SCOREP_MPI_ENABLED_IO_ERR ) )
    {
        SCOREP_MPI_EVENT_GEN_OFF();
        SCOREP_EnterRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_ERRHANDLER ] );

        return_val = PMPI_File_set_errhandler( file, errhandler );

        SCOREP_ExitRegion( scorep_mpi_regid[ SCOREP__MPI_FILE_SET_ERRHANDLER ] );
        SCOREP_MPI_EVENT_GEN_ON();
    }
    else
    {
        return_val = PMPI_File_set_errhandler( file, errhandler );
    }

    return return_val;
}
#endif


/**
 * @}
 * @name Fortran wrappers for handle conversion functions
 * @{
 */
