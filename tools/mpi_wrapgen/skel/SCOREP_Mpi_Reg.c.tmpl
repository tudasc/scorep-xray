/**
 * @file SCOREP_Mpi_Reg.c
 * @maintainer Daniel Lorenz <d.lorenz@fz-juelich.de>
 * @status     alpha
 * @ingroup    MPI_Wrapper
 *
 * @brief Registration of MPI regions
 */

#include <config.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#include "SCOREP_Mpi.h"

/* Placeholder for MPI functions which are not communicative */
#define SCOREP_REGION_NONE SCOREP_REGION_FUNCTION

/** 
 * MPI operation event type 
 */
typedef struct
{
  char*    name;
  uint32_t type;
} scorep_mpi_type;

/** MPI point-to-point function types
 * @note contents must be alphabetically sorted */
static const scorep_mpi_type scorep_mpi_pt2pt[] = {
  { "MPI_Bsend",            SCOREP_MPI_TYPE__SEND },
  { "MPI_Ibsend",           SCOREP_MPI_TYPE__SEND },
  { "MPI_Irsend",           SCOREP_MPI_TYPE__SEND },
  { "MPI_Isend",            SCOREP_MPI_TYPE__SEND },
  { "MPI_Issend",           SCOREP_MPI_TYPE__SEND },
  { "MPI_Recv",                                     SCOREP_MPI_TYPE__RECV },
  { "MPI_Rsend",            SCOREP_MPI_TYPE__SEND },
  { "MPI_Send",             SCOREP_MPI_TYPE__SEND },
  { "MPI_Sendrecv",         SCOREP_MPI_TYPE__SEND | SCOREP_MPI_TYPE__RECV },
  { "MPI_Sendrecv_replace", SCOREP_MPI_TYPE__SEND | SCOREP_MPI_TYPE__RECV },
  { "MPI_Ssend",            SCOREP_MPI_TYPE__SEND },
  { "MPI_Start",            SCOREP_MPI_TYPE__SEND },
  { "MPI_Startall",         SCOREP_MPI_TYPE__SEND },
  { "MPI_Test",                                     SCOREP_MPI_TYPE__RECV },
  { "MPI_Testall",                                  SCOREP_MPI_TYPE__RECV },
  { "MPI_Testany",                                  SCOREP_MPI_TYPE__RECV },
  { "MPI_Testsome",                                 SCOREP_MPI_TYPE__RECV },
  { "MPI_Wait",                                     SCOREP_MPI_TYPE__RECV },
  { "MPI_Waitall",                                  SCOREP_MPI_TYPE__RECV },
  { "MPI_Waitany",                                  SCOREP_MPI_TYPE__RECV },
  { "MPI_Waitsome",                                 SCOREP_MPI_TYPE__RECV },
};

/** MPI collective function types 
 * @note contents must be alphabetically sorted */
static const scorep_mpi_type scorep_mpi_colls[] = {
  { "MPI_Allgather",      SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Allgatherv",     SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Allreduce",      SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoall",       SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallv",      SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Alltoallw",      SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Barrier",        SCOREP_COLL_TYPE__BARRIER },
  { "MPI_Bcast",          SCOREP_COLL_TYPE__ONE2ALL },
  { "MPI_Cart_create",    SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Cart_sub",       SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Comm_create",    SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Comm_dup",       SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Comm_free",      SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Comm_split",     SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Exscan",         SCOREP_COLL_TYPE__PARTIAL },
  { "MPI_Finalize",       SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Gather",         SCOREP_COLL_TYPE__ALL2ONE },
  { "MPI_Gatherv",        SCOREP_COLL_TYPE__ALL2ONE },
  { "MPI_Init",           SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Init_thread",    SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Reduce",         SCOREP_COLL_TYPE__ALL2ONE },
  { "MPI_Reduce_scatter", SCOREP_COLL_TYPE__ALL2ALL },
  { "MPI_Scan",           SCOREP_COLL_TYPE__PARTIAL },
  { "MPI_Scatter",        SCOREP_COLL_TYPE__ONE2ALL },
  { "MPI_Scatterv",       SCOREP_COLL_TYPE__ONE2ALL },
  { "MPI_Win_create",     SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Win_fence",      SCOREP_COLL_TYPE__IMPLIED },
  { "MPI_Win_free",       SCOREP_COLL_TYPE__IMPLIED }
};

/** Region IDs of MPI functions */
SCOREP_RegionHandle scorep_mpi_regid[SCOREP__MPI_NUMFUNCS+1];

/**
 * Register MPI functions and initialize data structures
 */
void scorep_mpi_register_regions()
{
  /* Define source file handle for MPI functions */
  SCOREP_SourceFileHandle file_id = SCOREP_Definitions_NewSourceFile("MPI");

#pragma wrapgen multiple restrict() skel/SCOREP_Mpi_RegC.w

  /* Artificial root for MPI-only experiments when no user-code
   * instrumenation is available */
  scorep_mpi_regid[SCOREP_PARALLEL__MPI] =
      SCOREP_Definitions_NewRegion("PARALLEL", NULL, SCOREP_INVALID_SOURCE_FILE, SCOREP_INVALID_LINE_NO, 
                        SCOREP_INVALID_LINE_NO, SCOREP_ADAPTER_MPI, SCOREP_REGION_UNKNOWN);
}

/**
 * Compare function for binary search
 * @param v1 string to checked
 * @param v2 pointer to \p scorep_mpi_type structure
 * @return result is equivalent to \p strcasecmp result of two strings
 */
static int scorep_mpi_mycmp(const void *v1, const void *v2)
{
   return strcasecmp((char*)v1, ((scorep_mpi_type*)v2)->name);
}

/**
 * Check if region is flagged \a collective
 * @param str Region name
 * @return type of function if collective, 0 otherwise.
 */
uint8_t scorep_is_mpi_collective(const char* str)
{
  scorep_mpi_type * match =
    bsearch(str, (scorep_mpi_type*)scorep_mpi_colls, sizeof(scorep_mpi_colls)/sizeof(scorep_mpi_type),
	    sizeof(scorep_mpi_type), scorep_mpi_mycmp);

  return match ? match->type : 0;
}

/**
 * Check if region is flagged \a point-to-point
 * @param str Region name
 * @return type of function if point-to-point, 0 otherwise.
 */
uint8_t scorep_is_mpi_point2point(const char* str)
{
  scorep_mpi_type * match =
    bsearch(str, (scorep_mpi_type*)scorep_mpi_pt2pt, sizeof(scorep_mpi_pt2pt)/sizeof(scorep_mpi_type),
	    sizeof(scorep_mpi_type), scorep_mpi_mycmp);

  return match ? match->type : SCOREP_MPI_TYPE__NONE;
}

/**
 * Check if region is flagged either \a point-to-point or \a collective
 * @param  str Region name
 * @return type of function, if point-to-point or collective. 0,
 *         otherwise.
 */
uint8_t scorep_mpi_eventtype(const char* str)
{
  uint8_t type = scorep_is_mpi_point2point(str);
  if (type != SCOREP_MPI_TYPE__NONE)
      return type;

  type = (uint8_t) scorep_is_mpi_collective(str);
  switch (type) {
      case SCOREP_COLL_TYPE__BARRIER:
      case SCOREP_COLL_TYPE__ONE2ALL:
      case SCOREP_COLL_TYPE__ALL2ONE:
      case SCOREP_COLL_TYPE__ALL2ALL:
      case SCOREP_COLL_TYPE__PARTIAL:
          return SCOREP_MPI_TYPE__COLLECTIVE;
      default:
          break;
  }
  return SCOREP_MPI_TYPE__NONE;
}
