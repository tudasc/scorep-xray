/** @page instrumentation Application Instrumentation
@seclabel{instrumentation}

@scorep provides several possibilities to instrument user application code.
Besides the automatic compiler-based instrumentation 
(Section @secref{compiler_instrumentation}), it
provides manual instrumentation using the @scorep User API 
(Section @secref{manual_instrumentation}),
semi-automatic instrumentation using @pomp2 directives 
(Section @secref{pomp_instrumentation}) and,
if configured, automatic source-code instrumentation using the PDToolkit-based
instrumentor (Section @secref{tau_instrumentation}). 

As well as user routines and specified source regions, @scorep currently supports the
following kinds of events:

<ul>
  <li>
    <b>@mpi library calls</b>:<br>
    Instrumentation is accomplished using the standard @mpi profiling interface
    @pmpi. To enable it, the application program has to be linked against the
    @scorep @mpi (or hybrid) measurement library plus @mpi-specific libraries.
    Note that the @scorep libraries must be linked <i>before</i> the @mpi library
    to ensure interposition will be effective.
  </li>
  
  <li>
    <b>@openmp directives @& API calls</b>:<br>
    The @scorep measurement system uses the @opari2 tool for instrumentation
    of @openmp constructs. See the @opari2 documentation on how to instrument
    @openmp source code. In addition, the application must be linked with the @scorep
    @openmp (or hybrid) measurement library.
  </li>
</ul>

The @scorep instrumentor command <tt>scorep</tt> automatically takes
care of compilation and linking to produce an instrumented executable,
and should be prefixed to compile and link commands.  Often this only
requires prefixing definitions for @verb{CC} or @verb{MPICC} (and
equivalents) in Makefiles.  

When using Makefiles, it is often convenient to define a "preparation preposition"
placeholder (e.g., <tt>PREP</tt>) which can be prefixed to (selected)
compile and link commands:
@verbatim
    MPICC  = $(PREP) mpicc
    MPICXX = $(PREP) mpicxx
    MPIF90 = $(PREP) mpif90
@endverbatim
These can make it easier to prepare an instrumented version of the program with
@verbatim
    make PREP="scorep"
@endverbatim
while default builds (without specifying <tt>PREP</tt> on the command line)
remain fully optimized and without instrumentation.

In order to instrument applications which employ GNU Autotools for building, following 
instrumentation procedure has to be used:

<ol>
<li>Configure application as usual, but provide additional 
argument:  

<tt>--disable-dependency-tracking</tt></li>

<li>Build application using <tt>make</tt> command with compiler specification variables set as follows:

<tt>make CC="scorep <your-cc-compiler>"  \\

         CXX="scorep <your-cxx-compiler>" \\
 
         FC="scorep <your-fc-compiler>" ...</tt></li>
</ol>


When compiling without the @scorep instrumentor, the
<tt>scorep-config</tt> command can be used to simplify determining the appropriate
linker flags and libraries, or include paths:
@verbatim
    scorep-config [--seq|--omp|--mpi|--hyb] --libs [--fortran]
@endverbatim

The @verb{--seq}, @verb{--omp}, @verb{--mpi}, or @verb{--hyb} switch selects whether @mpi,
@openmp or hybrid @mpi/@openmp measurement support is desired. 

@note
  A particular installation of @scorep may not offer all measurement
  configurations!
	
The <tt>scorep-config</tt> command can also be used to determine the right compiler
flags for specifying the include directory of the <tt>scorep/SCOREP_User.h</tt> or
<tt>scorep/SCOREP_User.inc</tt> header files. When compiling without using the @scorep
instrumentor, necessary defines and compiler instrumentation flags can be obtained by calling:
@verbatim
    scorep-config --cflags [--fortran] [--user] [--nocompiler]
@endverbatim

If one wants to instrument Fortran code, <tt>--fortran</tt> should be added. The 
<tt>--user</tt> and <tt>--nocompiler</tt> options allow to get the compiler flags 
for non-default instrumentation possibilities. Thus <tt>--user</tt> enables the 
manual instrumentation with the @scorep user API, the <tt>--nocompiler</tt> option
disables compiler instrumentation. If Fortran code is instrumented, <tt>--fortran</tt> has to
be added.

@scorep supports a variety of instrumentation types for user-level
source routines and arbitrary regions, in addition to fully-automatic
@mpi and @openmp instrumentation, as summarized in Table @tabref{instopts}.

\if LATEX 
\latexonly
   \begin{table}
	\caption{Score-P instrumentor option overview}
	\label{tab:instopts}
    	\begin{tabular}{ | p{1.5cm} | p{2.5cm} | p{1.6cm} | p{2.1cm} | p{2.1cm} |}
	    \hline
	    \bf Type of\newline instrumen\-tation & \bf Instrumenter switch & \bf Default value & \bf Instrumented routines & \bf  Runtime measurement control \\ \hline
      
	    MPI & {\ttfamily -\/-\/mpi/ \newline -\/-\/nompi} & (auto) &  configured by install & see Sec. \ref{sec:mpi_groups}  \\ \hline	    
	    OpenMP & {\ttfamily -\/-\/openmp\-\_support/ \newline -\/-\/noopenmp\-\_support} & (auto) &  opari2 user re\-gions, Sec. \ref{sec:pomp_instrumentation} \newline + all parallel constructs  &  --  \\ \hline
	    Compiler, Sec. \ref{sec:compiler_instrumentation} & {\ttfamily -\/-\/compiler/ \newline -\/-\/nocompiler} & enabled &  all & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    PDT,\newline Sec. \ref{sec:tau_instrumentation} & {\ttfamily -\/-\/pdt/ \newline -\/-\/nopdt} & disabled &  all & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    OPARI2, Sec. \ref{sec:pomp_instrumentation} & {\ttfamily -\/-\/opari/ \newline -\/-\/noopari} & depends on OpenMP usage &  manually\newline annotated & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    Manual, Sec. \ref{sec:manual_instrumentation} & {\ttfamily -\/-\/user/ \newline -\/-\/nouser} & disabled &  manually\newline annotated & Filtering, Sec. \ref{sec:filtering}, and selective tracing, Sec. \ref{sec:selective_tracing}\\ \hline
    	\end{tabular}
    \end{table}
\endlatexonly

\else
  <table border=1 cellspacing=0>
    <caption>@scorep instrumentor option overview</caption>
    <tr>
      <th align="center" valign="middle" style="width:8em;">Type of instrumentation</th>
      <th align="center" valign="middle" style="width:8em;">Instrumenter switch</th>
      <th align="center" valign="middle" style="width:8em;">Default value</th>
      <th align="center" valign="middle" style="width:8em;">Instrumented routines</th>
      <th align="center" valign="middle" style="width:8em;">Runtime measurement control</th>
    </tr>
    <tr>
      <td align="left" valign="middle"> MPI </td>
      <td align="center" valign="middle"> --mpi/--nompi </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> configured by install </td>
      <td align="center" valign="middle"> (see Sec. @ref mpi_groups ) </td> 
    </tr>
    <tr>
      <td align="left" valign="middle"> OpenMP </td>
      <td align="center" valign="middle"> --openmp_support/--noopenmp_support </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> @opari2 user regions (see Sec. @ref pomp_instrumentation ) + all parallel constructs </td>
      <td align="center" valign="middle"> &mdash; </td> 
    </tr>
    <tr>
      <td align="left" valign="middle"> Compiler (see Sec. @ref compiler_instrumentation ) </td>
      <td align="center" valign="middle"> --compiler/--nocompiler </td>
      <td align="center" valign="middle"> enabled </td>
      <td align="center" valign="middle"> all </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </tt> </td> 
    </tr>
    <tr>
      <td align="left" valign="middle"> PDT instrumentation (see Sec. @ref tau_instrumentation ) </td>
      <td align="center" valign="middle"> --pdt/--nopdt </td>
      <td align="center" valign="middle"> disabled </td>
      <td align="center" valign="middle"> all </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </td> 
    </tr>
    <tr>
      <td align="left" valign="middle"> @opari2 (see Sec. @ref pomp_instrumentation ) </td>
      <td align="center" valign="middle"> --opari/--noopari </td>
      <td align="center" valign="middle"> depends on OpenMP usage </td>
      <td align="center" valign="middle"> manually annotated </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </td> 
    </tr>
    <tr>
      <td align="left" valign="middle"> Manual (see Sec. @ref manual_instrumentation ) </td>
      <td align="center" valign="middle"> --user/--nouser </td>
      <td align="center" valign="middle"> disabled </td>
      <td align="center" valign="middle"> manually annotated </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering )<br> and<br> selective tracing (see Sec. @ref selective_tracing ) </td> 
    </tr>
  </table>
\endif

When the instrumentor determines that MPI or OpenMP are being used, it
automatically enables MPI library instrumentation and OPARI2-based OpenMP
instrumentation, respectively.  The default set of instrumented MPI
library functions is specified when @scorep is installed.  All OpenMP
parallel constructs and API calls are instrumented by default.

By default, automatic instrumentation of user-level source routines by
the compiler is enabled (equivalent to specifying <tt>--compiler</tt>).
The compiler instrumentation can be disabled with <tt>--nocompiler</tt> when desired, 
such as when
using PDToolkit, or POMP2 or @scorep user API manual source annotations, are
enabled with <tt>--pdt</tt>, <tt>--opari</tt> and <tt>--user</tt>, respectively.
Compiler, PDToolkit, POMP2 and @scorep user API instrumentation can all be
used simultaneously, or in arbitrary combinations, however, it is
generally desirable to avoid instrumentation duplication (which would
result if all are used to instrument the same routines). Note that enabling
PDToolkit instrumentation automatically enables @scorep user instrumentation,
because it inserts @scorep user macros into the source code.

Sometimes it is desirable to explicitly direct the @scorep instrumentor to
do nothing except execute the associated compile/link command. For such cases 
it is possible to disable default instrumentation with <tt>--nocompiler</tt>,
<tt>--noopari</tt>, and/or <tt>--nompi</tt>. Although no instrumentation is
performed, this can help verify that the @scorep instrumentor correctly
handles the compile/link commands. 

@section compiler_instrumentation Automatic Compiler Instrumentation
@seclabel{compiler_instrumentation}

Most current compilers support automatic insertion of instrumentation calls at
routine entry and exit(s), and @scorep can use this capability to determine
which routines are included in an instrumented measurement.

Compiler instrumentation of all routines in the specified source file(s) is
enabled by default by @scorep, or can be explicitly requested with
@verb{--compiler}.  Compiler instrumentation is disabled with
@verb{--nocompiler}.

@note
  Depending on the compiler, and how it performs instrumentation, insertion of
  instrumentation may disable in-lining and other significant optimizations, or
  in-lined routines may not be instrumented at all (and therefore "invisible").

Automatic compiler-based instrumentation has been tested with a
number of different compilers:
<ul>
  <li> GCC (UNIX-like operating systems, not tested with Windows)</li>
  <li> @ibm xlc, xlC (version 7 or later, @ibm @bluegene)</li>
  <li> @ibm xlf (version 9.1 or later, @ibm @bluegene)</li>
  <li> PGI (on Linux)</li>
  <li> Intel compilers (version 10 or later, Linux)</li>
  <li> SUN Studio compilers (Linux, Fortran only)</li>
</ul>
In all cases, @scorep supports automatic instrumentation of C, C++ and,
Fortran codes, except for the SUN Studio compilers which only provide
appropriate support in their Fortran compiler.

@note
  The automatic compiler instrumentation might create a significant relative
  measurement overhead on short function calls. This can impact the overall
  application performance during measurement.  C++ applications are especially
  prone to suffer from this, depending on application design and whether C++ STL
  functions are also instrumented by the compiler. Currently, it is not
  possible to prevent the instrumentation of specific functions on all
  platforms when using automatic compiler instrumentation.

Names provided for instrumented routines depend on the compiler, which may
add underscores and other decorations to Fortran and C++ routine names, and
whether name "demangling" has been enabled when @scorep was installed
and could be applied successfully.


@section manual_instrumentation Manual Region Instrumentation
@seclabel{manual_instrumentation}

In addition to the automatic compiler-based instrumentation 
(see Section @secref{compiler_instrumentation}), 
instrumentation can be done manually. Manual instrumentation can
also be used to augment automatic instrumentation with region or phase
annotations, which can improve the structure of analysis reports. Furthermore, it
offers the possibility to record additional, user defined metrics. Generally,
the main program routine should be instrumented, so that the entire
execution is measured and included in the analysis.

Instrumentation can be performed in the following ways, depending on the
programming language used.

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      ! more declarations

      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo", SCOREP_USER_REGION_TYPE_COMMON )
      ! do something
      SCOREP_USER_REGION_END( my_region_handle )

    end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )

      // more declarations

      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )

      // do something

      SCOREP_USER_REGION_END( my_region_handle )
    }
@endcode

C++ only:
@code
    #include <scorep/SCOREP_User.h>
	
    void foo()
    {
      SCOREP_USER_REGION( "foo", SCOREP_USER_REGION_TYPE_FUNCTION )

      // do something
    }
@endcode

@note
  When using Fortran, make sure the C preprocessor expands the macros. In most cases,
  the fortran compiler invoke the C preprocessor if the source file suffix is in 
  capital letters. However, some compilers provide extra flags to tell the compiler
  to use a C preprocessor. 
  Furthermore, it is important to use the C-like <tt>#include</tt> with 
  the leading '#'-character to include the <tt>SCOREP_User.inc</tt> header file.
  Otherwise, the inclusion may happen after the C preprocessor ran. As result 
  the fortran compiler complains about unknown preprocessing directives. 


Region handles (<tt>my_region_handle</tt>) should be registered in each annotated
function/subroutine prologue before use within the associated body, and should
not already be declared in the same program scope. 
 
For every region, the region type can be indicated via the region type flag. 
Possible region types are:
<dl>
 <dt> SCOREP_USER_REGION_TYPE_COMMON </dt>
   <dd> Indicates regions without a special region type. </dd>
 <dt> SCOREP_USER_REGION_TYPE_FUNCTION </dt>
   <dd> Indicates that the region is a function or subroutine </dd>
 <dt> SCOREP_USER_REGION_TYPE_LOOP </dt>
   <dd> Indicates that the region is the body of a loop, with the same number of 
        iterations in all locations. </dd>
 <dt> SCOREP_USER_REGION_TYPE_DYNAMIC </dt>
   <dd> Set this type to create a separate branch in the call-tree for every execution
        of the region. See Section @secref{dynamic_profiling}. </dd>
 <dt> SCOREP_USER_REGION_TYPE_PHASE </dt>
   <dd> Indicates that this region belongs to a special phase. See Section 
        @secref{phase_profiling}. </dd>
</dl>
To create a region of combined region types you can connect two or more types with the
binary OR-operator, e.g.:
@code
   SCOREP_USER_REGION_BEGIN( handle, "foo",
                             SCOREP_USER_REGION_TYPE_LOOP |
                             SCOREP_USER_REGION_TYPE_PHASE |
                             SCOREP_USER_REGION_TYPE_DYNAMIC )  
@endcode

For function instrumentation in C and C++, @scorep provides macros, which 
automatically pass the name and function type to @scorep measurement system.
The <tt>SCOREP_USER_FUNC_BEGIN</tt> macro contains a variable definition.
Thus, compilers that require strict separation of declarion and excution part,
may not work with this macro.

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
        SCOREP_USER_FUNC_BEGIN()
        // do something
        SCOREP_USER_FUNC_END()
    }
@endcode

In some cases, it might be useful to have the possibility to define region
handles with a global scope. In C/C++, a region handle can be defined at a
global scope with <tt>SCOREP_GLOBAL_REGION_DEFINE</tt>. In this case, the 
<tt>SCOREP_USER_REGION_DEFINE</tt> must be omitted. The 
<tt>SCOREP_GLOBAL_REGION_DEFINE</tt> must only appear in one file. To use the same global
variable in other files, too, declare the global region in other files with
<tt>SCOREP_GLOBAL_REGION_EXTERNAL</tt>. 

File 1:
@code
    SCOREP_GLOBAL_REGION_DEFINE( global_handle )

    foo()
    {
        SCOREP_USER_REGION_BEGIN( global_handle, "phase 1", 
                                  SCOREP_USER_REGION_TYPE_PHASE)
        // do something
        SCOREP_USER_REGION_END( global_handle )
    }
@endcode

File 2:
@code
    SCOREP_GLOBAL_REGION_EXTERNAL( global_handle )

    bar()
    {
        SCOREP_USER_REGION_BEGIN( global_handle, "phase 1", 
                                  SCOREP_USER_REGION_TYPE_PHASE)
        // do something
        SCOREP_USER_REGION_END( global_handle )
    }
@endcode

@note These macros are not available in Fortran.


The source files instrumented with @scorep user macros have to be compiled with
<tt>-DSCOREP_USER_ENABLE</tt> otherwise <tt>SCOREP_*</tt> calls expand to nothing and are
ignored. If the @scorep instrumentor <tt>--user</tt> flag is used, the
<tt>SCOREP_USER_ENABLE</tt> symbol will be defined automatically. Also note, that Fortran
source files instrumented this way have to be preprocessed with the C
preprocessor (CPP).

Manual routine instrumentation in combination with automatic source-code
instrumentation by the compiler or PDT leads to double instrumentation of user
routines, i.e., usually only user region instrumentation is desired in this
case.


@section parameter_instrumentation Instrumentation for Parameter-Based Profiling
@seclabel{parameter_instrumentation}

The @scorep user API provides also macros for parameter-based profiling. In 
parameter-based profiling, the parameters of a function are used to split up the call-path
for executions of different parameter values. In @scorep parameter-based profiling is
supported for integer and string parameters. To associate a parameter value to a region
entry, insert a call to <tt>SCOREP_USER_PARAMETER_INT64</tt> for signed integer 
parameters, <tt>SCOREP_USER_PARAMETER_UINT64</tt> for unsigned integer parameters, or 
<tt>SCOREP_USER_PARAMETER_STRING</tt> for string parameters after the region entry 
(e.g. after 
<tt>SCOREP_USER_REGION_BEGIN</tt> or <tt>SCOREP_USER_FUNC_BEGIN</tt>). 

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo(i, s)
        integer :: i
        character (*) :: s

        SCOREP_USER_REGION_DEFINE( my_region_handle )
        SCOREP_PARAMETER_DEFINE( int_param )
        SCOREP_PARAMETER_DEFINE( string_param )
        SCOREP_USER_REGION_BEGIN( my_region_handle, "my_region",SCOREP_USER_REGION_TYPE_COMMON )
        SCOREP_USER_PARAMETER_INT64(int_param, "myint",i)
        SCOREP_USER_PARAMETER_UINT64(uint_param, "myuint",i)
        SCOREP_USER_PARAMETER_STRING(string_param, "mystring",s)

        // do something

        SCOREP_USER_REGION_END( my_region_handle )
     end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo(int64_t myint, uint64_t myuint, char *mystring)
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )
      SCOREP_USER_PARAMETER_INT64("myint",myint)
      SCOREP_USER_PARAMETER_UINT64("myuint",myuint)
      SCOREP_USER_PARAMETER_STRING("mystring",mystring)

      // do something

      SCOREP_USER_REGION_END( my_region_handle )
    }
@endcode

In C/C++, only a name for the parameter and the value needs to be provided. In Fortran, 
the handle must be defined first with <tt>SCOREP_PARAMETER_DEFINE</tt>. The defined handle
name must be unique in the current scope. The <tt>SCOREP_USER_PARAMETER_INT64</tt> and
<tt>SCOREP_USER_PARAMETER_STRING</tt> need the handle as the first argument, followed by the
name and the value.

@section control_instrumentation Measurement Control Instrumentation
@seclabel{control_instrumentation}

The @scorep user API also provides several macros for measurement control
that can be incorporated in source files and activated during
instrumentation. The macro <tt>SCOREP_RECORDING_OFF</tt> can be used to
(temporarily) pause recording of trace data until a subsequent
<tt>SCOREP_RECORDING_ON</tt>. Just like the already covered user-defined annotated
regions, <tt>SCOREP_RECORDING_ON</tt> and corresponding <tt>SCOREP_RECORDING_OFF</tt> 
must be correctly nested. Finally, with <tt>SCOREP_RECORDING_IS_ON</tt> you can test
whether recording is switched on. 

Events are not recorded when recording is switched off (though associated
definitions are), resulting in smaller measurement overhead.  In particular,
traces can be much smaller and can target specific application phases (e.g., 
excluding initialization and/or finalization) or specific iterations.  Since
the recording switch is process-local, and effects all threads on the process,
it can only be initiated outside of OpenMP parallel regions.  Switching recording
on/off is done independently on each MPI process without synchronization.

@note Switching recording on/off may result in inconsistent traces,
      if not applied with care. In particular, if communication is recorded incomplete
      (e.g. if the send is missing but the corresponding receive event is recorded)
      it may result in errors during execution or analysis. Furthermore, it is not
      possible to switch recording on/off from within parallel OpenMP regions. We
      recommend to use the selective tracing interface, instead of the manual on/off
      switch whenever possible. Special care is required in combination with 
      selective tracing (see Section @secref{selective_tracing}, which also 
      switches recording on/off.

@section online_access Source-Code Instrumentation Enabling Online Access
@seclabel{online_access}

The Online Access interface to the measurement system of Score-P allows remote
control of measurement and access to the profile data. The online access interface
may not be available on all platforms. To use the Online Access interface, @scorep must
have been built with Online Access (OA) support. 

The Online Access module requires the user to specify at least one 
\emph{online access phase}. The online access phase does not show the behavior of
a region of type phase as defined in Section @secref{manual_instrumentation}. 
However, the way to specify an online access phase is similar to manual region 
instrumentation. The start and end 
of the online access phase defines the interaction points, where new measurement 
control commands are applied and data requests are answered.

To insert an online online access phase into the code, the user has to insert the macros
<tt>SCOREP_USER_OA_PHASE_BEGIN</tt> and
<tt>SCOREP_USER_OA_PHASE_END</tt> at appropriate locations. These macros must be 
<ul>
 <li> correctly nested with all regions and </li>
 <li> must be potential global synchronization points. </li>
</ul>
Common practice is to mark the body of the application's main loop as online access 
phase, in order to utilize the main loop iterations for iterative online analysis. 
Only the measurements collected inside the OA phase could be configured and retrieved.

Instrumentation can be performed in the following ways, depending on the
programming language used.

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      ! more declarations

      SCOREP_USER_OA_PHASE_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )
      ! do something
      SCOREP_USER_OA_PHASE_END( my_region_handle )

    end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )

      // do something

      SCOREP_USER_OA_PHASE_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )

      // do something

      SCOREP_USER_OA_PHASE_END( my_region_handle )
    }
@endcode

@section pomp_instrumentation Semi-Automatic Instrumentation with @opari2
@seclabel{pomp_instrumentation}

If you manually instrument the desired user functions and regions of your
application source files using the @pomp2 <tt>INST</tt> directives described
below, the @scorep instrumentor <tt>--opari</tt> flag will generate
instrumentation for them. @pomp2 instrumentation directives are supported for
Fortran and C/C++. The main advantages are that
<ul>
  <li>
    being directives, the instrumentation is ignored during "normal"
    compilation and
  </li>
  <li>
    this semi-automatic instrumentation procedure can be used when fully
    automatic compiler instrumentation is not supported.
  </li>
</ul>

The <tt>INST BEGIN/END</tt> directives can be used to mark any user-defined
sequence of statements. If this block has several exit points (as is often
the case for functions), all but the last have to be instrumented by <tt>INST
ALTEND</tt>.

Fortran:
@code
    subroutine foo(...)
        !declarations
        !POMP$ INST BEGIN(foo)
        ...
        if (<condition>) then
            !POMP$ INST ALTEND(foo)
            return
        end if
        ...
        !POMP$ INST END(foo)
    end subroutine foo

@endcode

C/C++:
@code
    void foo(...)
    {
        /* declarations */
        #pragma pomp inst begin(foo)
        ...
        if (<condition>)
        {
            #pragma pomp inst altend(foo)
            return;
        }
        ...
        #pragma pomp inst end(foo)
    }
@endcode

At least the main program function has to be instrumented in this way, and
additionally, one of the following should be inserted as the first executable
statement of the main program:

Fortran:
@code
    program main
        ! declarations
        !POMP$ INST INIT
        ...
    end program main
@endcode

C/C++:
@code
    int main(int argc, char** argv)
    {
        /* declarations */
        #pragma pomp inst init
        ...
    }
@endcode

@section tau_instrumentation Source-Code Instrumentation Using PDT
@seclabel{tau_instrumentation}

If @scorep has been configured with PDToolkit support, automatic source-code
instrumentation can be used as an alternative instrumentation method. In this
case, the source code of the target application is pre-processed before
compilation, and appropriate @scorep user API calls will be inserted
automatically. However, please note that this feature is still somewhat
experimental and has a number of limitations (see Section @secref{tau_inst_limitations}).

To enable PDT-based source-code instrumentation, call <tt>scorep</tt> with the <tt>--pdt</tt> option, e.g.,
@verbatim
    scorep --pdt  mpicc -c foo.c
@endverbatim
This will by default instrument all routines found in <tt>foo.c</tt>. 
(To avoid double instrumentation, automatic compiler instrumentation can
be disabled with @verb{--nocompiler}.)

@subsection tau_inst_limitations Limitations
@seclabel{tau_inst_limitations}

Currently the support for the PDT-based source-code instrumentor still has a number 
of limitations:
<ul>
  <li>
    When instrumenting Fortran 77 applications, the inserted instrumentation
    code snippets do not yet adhere to the Fortran 77 line length limit.
    Typically, it is possible to work around this issue by supplying extra
    command line flags (e.g., <tt>-ffixed-line-length-132</tt> or
    <tt>-qfixed=132</tt>) to the compiler.
  </li>
  <li>
    Code in C/C++ header files as well as included code in Fortran (either
    using the C preprocessor or the <tt>include</tt> keyword) will currently
    not be instrumented.
  </li>
  <li>
    Support for C++ templates and classes is currently only partially
    implemented.
  </li>
  <li>
    Advanced TAU instrumentation features such as static/dynamic timers, loop,
    I/O and memory instrumentation are not yet supported. Respective entries
    in the selective instrumentation file will be ignored.
  </li>
</ul>

*/


