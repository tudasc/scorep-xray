/** @page instrumentation Application Instrumentation
@seclabel{instrumentation}

@scorep provides several possibilities to instrument user application code.
Besides the automatic compiler-based instrumentation
(Section @secref{compiler_instrumentation}), it
provides manual instrumentation using the @scorep User API
(Section @secref{manual_instrumentation}),
semi-automatic instrumentation using @pomp2 directives
(Section @secref{pomp_instrumentation}) and,
if configured, automatic source-code instrumentation using the PDToolkit-based
instrumenter (Section @secref{tau_instrumentation}).

As well as user routines and specified source regions, @scorep currently supports the
following kinds of events:

<dl>
  <dt>@mpi library calls:</dt>
  <dd>
    Instrumentation is accomplished using the standard @mpi profiling interface
    @pmpi. To enable it, the application program has to be linked against the
    @scorep @mpi (or hybrid) measurement library plus @mpi-specific libraries.
    Note that the @scorep libraries must be linked <i>before</i> the @mpi library
    to ensure interposition will be effective.
  </dd>

  <dt>@shmem library calls:</dt>
  <dd>
    Instrumentation is accomplished using the @shmem profiling interface
    or the GNU linker for library wrapping. To enable it, the application program
    has to be linked against the @scorep @shmem (or hybrid) measurement library
    plus @shmem-specific libraries. Note that the @scorep libraries must be linked
    <i>before</i> the @shmem library to ensure interposition will be effective.
  </dd>

  <dt>@openmp directives @& API calls:</dt>
  <dd>
    The @scorep measurement system uses the @opari2 tool for instrumentation
    of @openmp constructs. See the @opari2 documentation on how to instrument
    @openmp source code. In addition, the application must be linked with the @scorep
    @openmp (or hybrid) measurement library.
  </dd>

  <dt>Pthread library calls:</dt>
  <dd>
    The @scorep measurement system uses GNU linker for instrumentation
    of Pthreads library calls. At the moment only a few library calls are supported.
  </dd>
</dl>

The @scorep instrumenter command <tt>scorep</tt> automatically takes
care of compilation and linking to produce an instrumented executable,
and should be prefixed to compile and link commands.  Often this only
requires prefixing definitions for @verb{CC} or @verb{MPICC} (and
equivalents) in Makefiles.

Usually the @scorep instrumenter <tt>scorep</tt> is able to
automatically detect the programming paradigm from the set of compile
and link options given to the compiler. In some cases however, when
the compiler or compiler wrapper enables specific programming paradigm
by default (e.g., Pthreads on Cray and Blue Gene/Q systems),
<tt>scorep</tt> needs to be made aware of the programming paradigm in
order to do the correct instrumentation. Please see <tt>scorep
\--help</tt> for the available options.

When using Makefiles, it is often convenient to define a "preparation preposition"
placeholder (e.g., <tt>PREP</tt>) which can be prefixed to (selected)
compile and link commands:
@verbatim
    MPICC  = $(PREP) mpicc
    MPICXX = $(PREP) mpicxx
    MPIF90 = $(PREP) mpif90
@endverbatim
These can make it easier to prepare an instrumented version of the program with
@verbatim
    make PREP="scorep"
@endverbatim
while default builds (without specifying <tt>PREP</tt> on the command line)
remain fully optimized and without instrumentation.

In order to instrument applications which employ GNU Autotools for building, following
instrumentation procedure has to be used:

<ol>
<li>Configure application as usual, but provide additional
argument:

@code
--disable-dependency-tracking
@endcode
</li>

<li>Build application using <tt>make</tt> command with compiler specification variables set as follows:

@code
make CC="scorep <your-cc-compiler>"  \\
     CXX="scorep <your-cxx-compiler>" \\
     FC="scorep <your-fc-compiler>" ...
@endcode

</li>
</ol>


When compiling without the @scorep instrumenter, the
<tt>scorep-config</tt> command can be used to simplify determining the appropriate
linker flags and libraries, or include paths:
@verbatim
    scorep-config [--mpp=none|--mpp=mpi|--mpp=shmem] \
    [--thread=none|--thread=omp|--thread=pthread] --libs
@endverbatim

The @verb{--mpp=<paradigm>} switch selects which message passing paradigm is used.
Currently, @scorep supports applications using MPI ( @verb{--mpp=mpi} ) or SHMEM
( @verb{--mpp=shmem} ) and applications without any message passing paradigm.
It is not possible to specify two message passing systems for the same application.
The @verb{--thread=<paradigm>} switch selects which threading system is used in
@scorep. You may use OpenMP ( @verb{--thread=omp} ), no threading system
( @verb{--thread=none} ) or POSIX threading system ( @verb{--thread=pthread} ). It is not possible to specify two threading systems
for the same application. However, you may combine a message passing system with
a threading system.

@note
  A particular installation of @scorep may not offer all measurement
  configurations!

The <tt>scorep-config</tt> command can also be used to determine the right compiler
flags for specifying the include directory of the <tt>scorep/SCOREP_User.h</tt> or
<tt>scorep/SCOREP_User.inc</tt> header files. When compiling without using the @scorep
instrumenter, necessary defines and compiler instrumentation flags can be obtained by calling
one of the following, depending on the language:
@verbatim
    scorep-config --cflags [<options>]
    scorep-config --cxxflags [<options>]
    scorep-config --fflags [<options>]
@endverbatim

If you compile a C file, you should use <tt>\--cflags</tt>. If you use a C++ program,
you should use <tt>\--cxxflags</tt>. And if you compile a Fortran source file, you
should use <tt>\--flags</tt>.

With the additional options it is possible to select the used adapter, the threading system and
the message passing system. For each adapter, we provides a pair of flags of the form
<tt>\--adapter</tt>, and <tt>\--noadapter</tt> (please replace <tt>adapter</tt> by the
name of the adapter). This allows to get options
for non-default instrumentation possibilities. E.g., <tt>\--user</tt> enables the
manual instrumentation with the @scorep user API, the <tt>\--nocompiler</tt> option
disables compiler instrumentation.

@note
  Disabling OpenMP measurements with the <tt>\--noopenmp</tt> flag,
  disables all except parallel regions. Internally Score-P needs to
  track events on a per-thread basis and thus needs to be aware of the
  creation and destruction of OpenMP threads. Accordingly these
  regions will also show up in the measurements.

@scorep supports a variety of instrumentation types for user-level
source routines and arbitrary regions, in addition to fully-automatic
@mpi and @openmp instrumentation, as summarized in Table @tabref{instopts}.

\if LATEX
\latexonly
   \begin{table}
	\caption{Score-P instrumenter option overview}
	\label{tab:instopts}
    	\begin{tabular}{ | p{1.7cm} | p{3.0cm} | p{1.6cm} | p{2.1cm} | p{2.1cm} |}
	    \hline
	    \bf Type of\newline instrumen\-tation & \bf Instrumenter switch & \bf Default value & \bf Instrumented routines & \bf  Runtime measurement control \\ \hline

	    MPI & {\ttfamily -\/-\/mpp=mpi/ \newline -\/-\/mpp=none} & (auto) &  configured by install & see Sec. \ref{sec:mpi_groups}  \\ \hline
	    SHMEM & {\ttfamily -\/-\/mpp=shmem/ \newline -\/-\/mpp=none} & (auto) &  configured by install & --  \\ \hline
	    OpenCL & {\ttfamily -\/-\/opencl/ \newline -\/-\/noopencl} & enabled &  configured by install & see Sec. \ref{sec:opencl_adapter}  \\ \hline
	    OpenACC & {\ttfamily -\/-\/openacc/ \newline -\/-\/noopenacc} & enabled &  configured by install & see Sec. \ref{sec:openacc_adapter}  \\ \hline
	    OpenMP & {\ttfamily -\/-\/thread=omp/ \newline -\/-\/thread=none \newline -\/-\/openmp \newline -\/-\/noopenmp} & (auto)  &  all parallel constructs &  --  \\ \hline
	    Pthread & {\ttfamily -\/-\/thread= \newline pthread} & (auto) &  Basic Pthread library calls &  --  \\ \hline
	    Compiler, Sec. \ref{sec:compiler_instrumentation} & {\ttfamily -\/-\/compiler/ \newline -\/-\/nocompiler} & enabled &  all & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    PDT,\newline Sec. \ref{sec:tau_instrumentation} & {\ttfamily -\/-\/pdt/ \newline -\/-\/nopdt} & disabled &  all & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    POMP2 user regions, Sec. \ref{sec:pomp_instrumentation} & {\ttfamily -\/-\/pomp/ \newline -\/-\/nopomp} & disabled &  manually\newline annotated & Filtering, Sec. \ref{sec:filtering}  \\ \hline
	    Manual, Sec. \ref{sec:manual_instrumentation} & {\ttfamily -\/-\/user/ \newline -\/-\/nouser} & disabled &  manually\newline annotated & Filtering, Sec. \ref{sec:filtering}, and selective recording, Sec. \ref{sec:selective_recording}\\ \hline
    	\end{tabular}
    \end{table}
\endlatexonly

\else
  <table border=1 cellspacing=0>
    <caption>@scorep instrumenter option overview</caption>
    <tr>
      <th align="center" valign="middle" style="width:8em;">Type of instrumentation</th>
      <th align="center" valign="middle" style="width:8em;">Instrumenter switch</th>
      <th align="center" valign="middle" style="width:8em;">Default value</th>
      <th align="center" valign="middle" style="width:8em;">Instrumented routines</th>
      <th align="center" valign="middle" style="width:8em;">Runtime measurement control</th>
    </tr>
    <tr>
      <td align="left" valign="middle"> MPI </td>
      <td align="center" valign="middle"> \--mpp=mpi </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> configured by install </td>
      <td align="center" valign="middle"> (see Sec. @ref mpi_groups ) </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> SHMEM </td>
      <td align="center" valign="middle"> \--mpp=shmem/\--mpp=none </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> configured by install </td>
      <td align="center" valign="middle"> &mdash; </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> OpenCL </td>
      <td align="center" valign="middle"> \--opencl/\--noopencl </td>
      <td align="center" valign="middle"> enabled </td>
      <td align="center" valign="middle"> configured by install </td>
      <td align="center" valign="middle"> (see Sec. @ref opencl_adapter ) </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> OpenACC </td>
      <td align="center" valign="middle"> \--openacc/\--noopenacc </td>
      <td align="center" valign="middle"> enabled </td>
      <td align="center" valign="middle"> configured by install </td>
      <td align="center" valign="middle"> (see Sec. @ref openacc_adapter ) </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> OpenMP </td>
      <td align="center" valign="middle"> \--thread=omp / \--no|openmp </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> all parallel constructs </td>
      <td align="center" valign="middle"> &mdash; </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> Pthread </td>
      <td align="center" valign="middle"> \--thread=pthread </td>
      <td align="center" valign="middle"> (auto) </td>
      <td align="center" valign="middle"> Basic Pthread library calls  </td>
      <td align="center" valign="middle"> &mdash; </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> Compiler (see Sec. @ref compiler_instrumentation ) </td>
      <td align="center" valign="middle"> \--compiler/\--nocompiler </td>
      <td align="center" valign="middle"> enabled </td>
      <td align="center" valign="middle"> all </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </tt> </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> PDT instrumentation (see Sec. @ref tau_instrumentation ) </td>
      <td align="center" valign="middle"> \--pdt/\--nopdt </td>
      <td align="center" valign="middle"> disabled </td>
      <td align="center" valign="middle"> all </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> @pomp2 user regions (see Sec. @ref pomp_instrumentation ) </td>
      <td align="center" valign="middle"> \--pomp/\--nopomp</td>
      <td align="center" valign="middle"> disabled </td>
      <td align="center" valign="middle"> manually annotated </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering ) </td>
    </tr>
    <tr>
      <td align="left" valign="middle"> Manual (see Sec. @ref manual_instrumentation ) </td>
      <td align="center" valign="middle"> \--user/\--nouser </td>
      <td align="center" valign="middle"> disabled </td>
      <td align="center" valign="middle"> manually annotated </td>
      <td align="center" valign="middle"> Filtering (see Sec. @ref filtering )<br> and<br> selective recording (see Sec. @ref selective_recording ) </td>
    </tr>
  </table>
\endif

When the instrumenter determines that MPI or OpenMP are being used, it
automatically enables MPI library instrumentation or OPARI2-based OpenMP
instrumentation, respectively.  The default set of instrumented MPI
library functions is specified when @scorep is installed.  All OpenMP
parallel constructs and API calls are instrumented by default.

@note To fine-tune instrumentation of OpenMP regions, use the
      <tt>\--opari=<parameter-list></tt> option. For available parameters please
      refer to the OPARI2 manual.

@note Since Score-P version 1.3 there were two variants of internal
      OpenMP data handling, namely @verb{--thread=omp:pomp_tpd} and
      @verb{--thread=omp:ancestry}, depending on the functionality
      available on the target system. From Score-P version 4 on, due
      to internal refactorings, we replace the two OpenMP threading
      variants by only one: @verb{--thread=omp}. The possible
      options are detected at configure time. If both are available,
      the ancestry mechanism will be used by default.

By default, automatic instrumentation of user-level source routines by
the compiler is enabled (equivalent to specifying <tt>\--compiler</tt>).
The compiler instrumentation can be disabled with <tt>\--nocompiler</tt> when desired,
such as when
using PDToolkit, or POMP2 or @scorep user API manual source annotations, are
enabled with <tt>\--pdt</tt>, <tt>\--pomp</tt> and <tt>\--user</tt>, respectively.
Compiler, PDToolkit, POMP2 and @scorep user API instrumentation can all be
used simultaneously, or in arbitrary combinations, however, it is
generally desirable to avoid instrumentation duplication (which would
result if all are used to instrument the same routines). Note that enabling
PDToolkit instrumentation automatically enables @scorep user instrumentation,
because it inserts @scorep user macros into the source code.

Sometimes it is desirable to explicitly direct the @scorep instrumenter to
do nothing except execute the associated compile/link command. For such cases
it is possible to disable default instrumentation with <tt>\--nocompiler</tt>,
<tt>\--thread=none</tt>, and/or <tt>\--mpp=none</tt>. Although no instrumentation is
performed, this can help verify that the @scorep instrumenter correctly
handles the compile/link commands.

@note Disabling @openmp in the instrumenter for @openmp applications will cause
      errors during program execution if any event occurs inside of a parallel
      region.

Each thread model uses a default internal locking mechanism for the @scorep
measurement system. For the standard use case there is no need to specify an
explicit locking mode. However, on certain systems or for performance
reasons it might be useful to change the locking mode. For
these cases the instrumenter provides the option
 @verb{--mutex=[omp|pthread|pthread:spinlock|pthread:wrap|none]}.
Current possibilities are  the OpenMP locking (omp), Pthread mutex
(pthread), Pthread spinlock (pthread:spinlock), Pthread mutex, where original functions replaced with __real functions (pthread:wrap), and none at all (none). Which of
these are available for a given installation will be determined at configure time.

@note Not all combinations of thread model and explicit choice of locking
      are useful. Currently, only the combination of no locking with a real
      threading system is overwritten by the thread model default to ensure
      thread safety.

@section compiler_instrumentation Automatic Compiler Instrumentation
@seclabel{compiler_instrumentation}

Most current compilers support automatic insertion of instrumentation calls at
routine entry and exit(s), and @scorep can use this capability to determine
which routines are included in an instrumented measurement.

Compiler instrumentation of all routines in the specified source file(s) is
enabled by default by @scorep, or can be explicitly requested with
@verb{--compiler}.  Compiler instrumentation is disabled with
@verb{--nocompiler}.

@note
  Depending on the compiler, and how it performs instrumentation, insertion of
  instrumentation may disable in-lining and other significant optimizations, or
  in-lined routines may not be instrumented at all (and therefore "invisible").

Automatic compiler-based instrumentation has been tested with a
number of different compilers:
<ul>
  <li> GCC (UNIX-like operating systems, not tested with Windows)</li>
  <li> @ibm xlc, xlC (version 7 or later, @ibm @bluegene)</li>
  <li> @ibm xlf (version 9.1 or later, @ibm @bluegene)</li>
  <li> PGI (on Linux)</li>
  <li> Intel compilers (version 10 or later, Linux)</li>
  <li> SUN Studio compilers (Linux, Fortran only)</li>
</ul>
In all cases, @scorep supports automatic instrumentation of C, C++ and,
Fortran codes, except for the SUN Studio compilers which only provide
appropriate support in their Fortran compiler.

@note
  The automatic compiler instrumentation might create a significant relative
  measurement overhead on short function calls. This can impact the overall
  application performance during measurement.  C++ applications are especially
  prone to suffer from this, depending on application design and whether C++ STL
  functions are also instrumented by the compiler. Currently, it is not
  possible to prevent the instrumentation of specific functions on all
  platforms when using automatic compiler instrumentation.

@note
  As an exception, the GCC plug-in based function instrumentation supports all
  filtering features when using the @verb{--instrument-filter} flag to the
  @scorep instrumenter (see Sec. @secref{filtering}).

Names provided for instrumented routines depend on the compiler, which may
add underscores and other decorations to Fortran and C++ routine names, and
whether name "demangling" has been enabled when @scorep was installed
and could be applied successfully.


@section manual_instrumentation Manual Region Instrumentation
@seclabel{manual_instrumentation}

In addition to the automatic compiler-based instrumentation
(see Section @secref{compiler_instrumentation}),
instrumentation can be done manually. Manual instrumentation can
also be used to augment automatic instrumentation with region or phase
annotations, which can improve the structure of analysis reports. Furthermore, it
offers the possibility to record additional, user defined metrics. Generally,
the main program routine should be instrumented, so that the entire
execution is measured and included in the analysis.

Instrumentation can be performed in the following ways, depending on the
programming language used.

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      ! more declarations

      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo", SCOREP_USER_REGION_TYPE_COMMON )
      ! do something
      SCOREP_USER_REGION_END( my_region_handle )

    end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )

      // more declarations

      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )

      // do something

      SCOREP_USER_REGION_END( my_region_handle )
    }
@endcode

C++ only:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
      SCOREP_USER_REGION( "foo", SCOREP_USER_REGION_TYPE_FUNCTION )

      // do something
    }
@endcode

@note
  When using Fortran, make sure the C preprocessor expands the macros. In most cases,
  the fortran compiler invoke the C preprocessor if the source file suffix is in
  capital letters. However, some compilers provide extra flags to tell the compiler
  to use a C preprocessor.
  Furthermore, it is important to use the C-like <tt>#include</tt> with
  the leading '#'-character to include the <tt>SCOREP_User.inc</tt> header file.
  Otherwise, the inclusion may happen after the C preprocessor ran. As result
  the fortran compiler complains about unknown preprocessing directives.


Region handles (<tt>my_region_handle</tt>) should be registered in each annotated
function/subroutine prologue before use within the associated body, and should
not already be declared in the same program scope.

For every region, the region type can be indicated via the region type flag.
Possible region types are:
<dl>
 <dt> SCOREP_USER_REGION_TYPE_COMMON </dt>
   <dd> Indicates regions without a special region type. </dd>
 <dt> SCOREP_USER_REGION_TYPE_FUNCTION </dt>
   <dd> Indicates that the region is a function or subroutine </dd>
 <dt> SCOREP_USER_REGION_TYPE_LOOP </dt>
   <dd> Indicates that the region is the body of a loop, with the same number of
        iterations in all locations. </dd>
 <dt> SCOREP_USER_REGION_TYPE_DYNAMIC </dt>
   <dd> Set this type to create a separate branch in the call-tree for every execution
        of the region. See Section @secref{dynamic_profiling}. </dd>
 <dt> SCOREP_USER_REGION_TYPE_PHASE </dt>
   <dd> Indicates that this region belongs to a special phase. See Section
        @secref{phase_profiling}. </dd>
</dl>
To create a region of combined region types you can connect two or more types with the
binary OR-operator, e.g.:
@code
   SCOREP_USER_REGION_BEGIN( handle, "foo",
                             SCOREP_USER_REGION_TYPE_LOOP |
                             SCOREP_USER_REGION_TYPE_PHASE |
                             SCOREP_USER_REGION_TYPE_DYNAMIC )
@endcode

For function instrumentation in C and C++, @scorep provides macros, which
automatically pass the name and function type to @scorep measurement system.
The <tt>SCOREP_USER_FUNC_BEGIN</tt> macro contains a variable definition.
Thus, compilers that require strict separation of declaration and execution part,
may not work with this macro.

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
        SCOREP_USER_FUNC_BEGIN()
        // do something
        SCOREP_USER_FUNC_END()
    }
@endcode

In some cases, it might be useful to have the possibility to define region
handles with a global scope. In C/C++, a region handle can be defined at a
global scope with <tt>SCOREP_USER_GLOBAL_REGION_DEFINE</tt>. In this case, the
<tt>SCOREP_USER_REGION_DEFINE</tt> must be omitted. The
<tt>SCOREP_USER_GLOBAL_REGION_DEFINE</tt> must only appear in one file. To use the same global
variable in other files, too, declare the global region in other files with
<tt>SCOREP_USER_GLOBAL_REGION_EXTERNAL</tt>.

File 1:
@code
    SCOREP_USER_GLOBAL_REGION_DEFINE( global_handle )

    foo()
    {
        SCOREP_USER_REGION_BEGIN( global_handle, "phase 1",
                                  SCOREP_USER_REGION_TYPE_PHASE)
        // do something
        SCOREP_USER_REGION_END( global_handle )
    }
@endcode

File 2:
@code
    SCOREP_USER_GLOBAL_REGION_EXTERNAL( global_handle )

    bar()
    {
        SCOREP_USER_REGION_BEGIN( global_handle, "phase 1",
                                  SCOREP_USER_REGION_TYPE_PHASE)
        // do something
        SCOREP_USER_REGION_END( global_handle )
    }
@endcode

@note These macros are not available in Fortran.

In addition, the macros <tt>SCOREP_USER_REGION_BY_NAME_BEGIN( name, type )</tt> and
<tt>SCOREP_USER_REGION_BY_NAME_END( name )</tt> are available. These macros might
introduce more overhead than the standard macros but can annotate user regions
without the need to take care about the handle struct. This might be useful for
automatically generating instrumented code or to avoid global declaration
of this variable.

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    /* Application functions are already instrumented with these two calls. */
    void instrument_begin(const char* regionname)
    {
      /* code added for Score-P instrumentation */
      SCOREP_USER_REGION_BY_NAME_BEGIN( regionname, SCOREP_USER_REGION_TYPE_COMMON )
    }

    void instrument_end(const char* regionname)
    {
      SCOREP_USER_REGION_BY_NAME_END( regionname )
    }
@endcode

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine instrument_begin(regionname)
      character(len=*) :: regionname
      SCOREP_USER_REGION_BY_NAME_BEGIN( regionname, SCOREP_USER_REGION_TYPE_COMMON )
    end subroutine instrument_begin

    subroutine instrument_end(regionname)
      character(len=*) :: regionname
      SCOREP_USER_REGION_BY_NAME_END( regionname )
    end subroutine instrument_end
@endcode

@note When using the "BY_NAME" macros in Fortran, be aware of section 12.4.1.1 of the
      F90/95/2003 standard. If you pass <i>name</i> through a dummy argument of a subroutine
      the length <i>len</i> of the character array <i>name</i> must be exactly the size of the
      actual string passed. In the Fortran examples above this is assured by `len=*`.

@note To ensure correct nesting, avoid automatic compiler instrumentation for these helper
      functions.

The source files instrumented with @scorep user macros have to be compiled with
<tt>-DSCOREP_USER_ENABLE</tt> otherwise <tt>SCOREP_*</tt> calls expand to nothing and are
ignored. If the @scorep instrumenter <tt>\--user</tt> flag is used, the
<tt>SCOREP_USER_ENABLE</tt> symbol will be defined automatically. Also note, that Fortran
source files instrumented this way have to be preprocessed with the C
preprocessor (CPP).

Manual routine instrumentation in combination with automatic source-code
instrumentation by the compiler or PDT leads to double instrumentation of user
routines, i.e., usually only user region instrumentation is desired in this
case.


@section parameter_instrumentation Instrumentation for Parameter-Based Profiling
@seclabel{parameter_instrumentation}

The @scorep user API provides also macros for parameter-based profiling. In
parameter-based profiling, the parameters of a function are used to split up the call-path
for executions of different parameter values. In @scorep parameter-based profiling is
supported for integer and string parameters. To associate a parameter value to a region
entry, insert a call to <tt>SCOREP_USER_PARAMETER_INT64</tt> for signed integer
parameters, <tt>SCOREP_USER_PARAMETER_UINT64</tt> for unsigned integer parameters, or
<tt>SCOREP_USER_PARAMETER_STRING</tt> for string parameters after the region entry
(e.g., after <tt>SCOREP_USER_REGION_BEGIN</tt> or <tt>SCOREP_USER_FUNC_BEGIN</tt>).

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo(i, s)
        integer :: i
        character (*) :: s

        SCOREP_USER_REGION_DEFINE( my_region_handle )
        SCOREP_USER_PARAMETER_DEFINE( int_param )
        SCOREP_USER_PARAMETER_DEFINE( string_param )
        SCOREP_USER_REGION_BEGIN( my_region_handle, "my_region",SCOREP_USER_REGION_TYPE_COMMON )
        SCOREP_USER_PARAMETER_INT64(int_param, "myint",i)
        SCOREP_USER_PARAMETER_UINT64(uint_param, "myuint",i)
        SCOREP_USER_PARAMETER_STRING(string_param, "mystring",s)

        // do something

        SCOREP_USER_REGION_END( my_region_handle )
     end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo(int64_t myint, uint64_t myuint, char *mystring)
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      SCOREP_USER_REGION_BEGIN( my_region_handle, "foo",SCOREP_USER_REGION_TYPE_COMMON )
      SCOREP_USER_PARAMETER_INT64("myint",myint)
      SCOREP_USER_PARAMETER_UINT64("myuint",myuint)
      SCOREP_USER_PARAMETER_STRING("mystring",mystring)

      // do something

      SCOREP_USER_REGION_END( my_region_handle )
    }
@endcode

In C/C++, only a name for the parameter and the value needs to be provided. In Fortran,
the handle must be defined first with <tt>SCOREP_USER_PARAMETER_DEFINE</tt>. The defined handle
name must be unique in the current scope. The macro <tt>SCOREP_USER_PARAMETER_INT64</tt>
as well as the macro
<tt>SCOREP_USER_PARAMETER_STRING</tt> need the handle as the first argument, followed by the
name and the value.

@section control_instrumentation Measurement Control Instrumentation
@seclabel{control_instrumentation}

The @scorep user API also provides several macros for measurement control
that can be incorporated in source files and activated during
instrumentation. The macro
<tt>SCOREP_RECORDING_OFF</tt> can be used to
(temporarily) pause recording until a subsequent
<tt>SCOREP_RECORDING_ON</tt>. Just like the already covered user-defined annotated
regions, <tt>SCOREP_RECORDING_ON</tt> and the corresponding
 <tt>SCOREP_RECORDING_OFF</tt>
 must be correctly nested with other enter/exit events. Please beware
that if program start is recorded, i.e., <tt>main</tt> or
<tt>MAIN_</tt> are instrumented and not filtered, the recording needs
to be switched on before program end in order to get valid
measurements.
Finally, with <tt>SCOREP_RECORDING_IS_ON</tt> you can test whether
recording is switched on.

Events are not recorded when recording is switched off (though associated
definitions are), resulting in smaller measurement overhead.  In particular,
traces can be much smaller and can target specific application phases (e.g.,
excluding initialization and/or finalization) or specific iterations.  Since
the recording switch is process-local, and effects all threads on the process,
it can only be initiated outside of OpenMP parallel regions.  Switching recording
on/off is done independently on each MPI process without synchronization.

@note Switching recording on/off may result in inconsistent traces or profiles,
      if not applied with care. In particular, if communication is recorded incomplete
      (e.g., if the send is missing but the corresponding receive event is recorded)
      it may result in errors during execution or analysis. Furthermore, it is not
      possible to switch recording on/off from within parallel OpenMP regions. We
      recommend to use the selective recording interface, instead of the manual on/off
      switch whenever possible. Special care is required in combination with
      selective recording (see Section @secref{selective_recording}, which also
      switches recording on/off.

@section online_access Source-Code Instrumentation Enabling Online Access
@seclabel{online_access}

The Online Access interface to the measurement system of @scorep allows remote
control of measurement and access to the profile data. The online access interface
may not be available on all platforms. To use the Online Access interface, @scorep must
have been built with Online Access (OA) support.

The Online Access module requires the user to specify at least one
\emph{online access phase}. The online access phase does not show the behavior of
a region of type phase as defined in Section @secref{manual_instrumentation}.
However, the way to specify an online access phase is similar to manual region
instrumentation. The start and end
of the online access phase defines the interaction points, where new measurement
control commands are applied and data requests are answered.

To insert an online access phase into the code, the user has to insert the macros
<tt>SCOREP_USER_OA_PHASE_BEGIN</tt> and the corresponding
<tt>SCOREP_USER_OA_PHASE_END</tt> at appropriate locations. These macros must be
<ul>
 <li> correctly nested with all regions and </li>
 <li> must be potential global synchronization points. </li>
</ul>
Common practice is to mark the body of the application's main loop as online access
phase, in order to utilize the main loop iterations for iterative online analysis.
Only the measurements collected inside the OA phase could be configured and retrieved.

Instrumentation can be performed in the following ways, depending on the
programming language used.

Fortran:
@code
    #include "scorep/SCOREP_User.inc"

    subroutine foo
      SCOREP_USER_REGION_DEFINE( my_region_handle )
      ! more declarations

      SCOREP_USER_OA_PHASE_BEGIN( my_region_handle, "foo", SCOREP_USER_REGION_TYPE_COMMON )
      ! do something
      SCOREP_USER_OA_PHASE_END( my_region_handle )

    end subroutine foo
@endcode

C/C++:
@code
    #include <scorep/SCOREP_User.h>

    void foo()
    {
      SCOREP_USER_REGION_DEFINE( my_region_handle )

      // do something

      SCOREP_USER_OA_PHASE_BEGIN( my_region_handle, "foo", SCOREP_USER_REGION_TYPE_COMMON )

      // do something

      SCOREP_USER_OA_PHASE_END( my_region_handle )
    }
@endcode

@section pomp_instrumentation Semi-Automatic Instrumentation of @pomp2 User Regions
@seclabel{pomp_instrumentation}

@note Since @scorep version 1.4, OpenMP instrumentation using @opari2
no longer activates @pomp2 instrumentation implicitly. You need to
explicitly add the <tt>\--pomp</tt> option to the @scorep instrumenter.

If you manually instrument the desired user functions and regions of
your application source files using the @pomp2 <tt>INST</tt>
directives described below, the @scorep instrumenter <tt>\--pomp</tt>
flag will generate instrumentation for them. @pomp2 instrumentation
directives are supported for Fortran and C/C++. The main advantages
are that
<ul>
  <li>
    being directives, the instrumentation is ignored during "normal"
    compilation and
  </li>
  <li>
    this semi-automatic instrumentation procedure can be used when fully
    automatic compiler instrumentation is not supported.
  </li>
</ul>

The <tt>INST BEGIN/END</tt> directives can be used to mark any user-defined
sequence of statements. If this block has several exit points (as is often
the case for functions), all but the last have to be instrumented by <tt>INST
ALTEND</tt>.

Fortran:
@code
    subroutine foo(...)
        !declarations
        !POMP$ INST BEGIN(foo)
        ...
        if (<condition>) then
            !POMP$ INST ALTEND(foo)
            return
        end if
        ...
        !POMP$ INST END(foo)
    end subroutine foo

@endcode

C/C++:
@code
    void foo(...)
    {
        /* declarations */
        #pragma pomp inst begin(foo)
        ...
        if (<condition>)
        {
            #pragma pomp inst altend(foo)
            return;
        }
        ...
        #pragma pomp inst end(foo)
    }
@endcode

At least the main program function has to be instrumented in this way, and
additionally, one of the following should be inserted as the first executable
statement of the main program:

Fortran:
@code
    program main
        ! declarations
        !POMP$ INST INIT
        ...
    end program main
@endcode

C/C++:
@code
    int main(int argc, char** argv)
    {
        /* declarations */
        #pragma pomp inst init
        ...
    }
@endcode

By default, the source code is preprocessed before @pomp2 instrumentation happens.
For more information on the preprocessing, see Section @secref{opari2_preprocessing}.

@section opari2_preprocessing Preprocessing before @pomp2 and @openmp instrumentation
@seclabel{opari2_preprocessing}

By default, source files are preprocessed before the semi-automatic @pomp2 instrumentation
or the OpenMP construct instrumentation with @opari2 happens. This ensures, that all
constructs and regions that might be contained in header files, templates, or macros
are properly instrumented. Furthermore, conditional compilation directives take
effect, too. The necessary steps are performed by the @scorep instrumenter tool.

Some Fortran compilers do not regard information about the original
source location that the preprocessing leaves in
the preprocessed code. This causes wrong source code information for
regions from compiler instrumentation, and manual source code
instrumentation. However, these compilers also
disregard the source code information left by @opari2. Thus,
for these compilers the source location information is incorrect anyway.

If the preprocessing is not desired, you can disable it
with the <tt>\--nopreprocess</tt> flag. In this case the instrumentation is performed
before the preprocessing happens. In this case constructs and regions in header
files, macros, or templates are not instrumented. Conditional compilation directives
around constructs may also lead to broken instrumentation.

@note If a parallel region is not instrumented, the application will
      crash during runtime.

The preprocessing does not work in combination with PDT source
code instrumentation. Thus, if PDT instrumentation is enabled, it changes
the default to not preprocess a source file. If you manually specify
preprocessing and PDT source code instrumentation, the instrumenter will
abort with an error.


@section tau_instrumentation Source-Code Instrumentation Using PDT
@seclabel{tau_instrumentation}

If @scorep has been configured with PDToolkit support, automatic source-code
instrumentation can be used as an alternative instrumentation method. In this
case, the source code of the target application is pre-processed before
compilation, and appropriate @scorep user API calls will be inserted
automatically. However, please note that this feature is still somewhat
experimental and has a number of limitations (see Section @secref{tau_inst_limitations}).

To enable PDT-based source-code instrumentation, call <tt>scorep</tt> with the <tt>\--pdt</tt> option, e.g.,
@verbatim
    scorep --pdt  mpicc -c foo.c
@endverbatim
This will by default instrument all routines found in <tt>foo.c</tt>.
(To avoid double instrumentation, automatic compiler instrumentation is
disabled when using Source-Code Instrumentation with PDT. However,
if you you can enforce additional compiler instrumentation with
@verb{--compiler}.)
The underlying PDT instrumentor supports a set a instrumentation options, which
can be set like
@verbatim
    scorep --pdt="-f <inclusion/exclusion file>"  mpicc -c foo.c
@endverbatim
This particular option for example can be used to manually include/exclude
specific functions from the instrumentation process.
The respective file format is described
@href{http://www.cs.uoregon.edu/research/tau/docs/newguide/bk01ch01s03.html,here}.
Please check the documentation about the
@href{http://www.cs.uoregon.edu/research/tau/docs/newguide/re34.html,tau_instrumentor}
for more valid options.

@subsection tau_inst_limitations Limitations
@seclabel{tau_inst_limitations}

Currently the support for the PDT-based source-code instrumenter still has a number
of limitations:
<ul>
  <li>
    When instrumenting Fortran 77 applications, the inserted instrumentation
    code snippets do not yet adhere to the Fortran 77 line length limit.
    Typically, it is possible to work around this issue by supplying extra
    command line flags (e.g., <tt>-ffixed-line-length-132</tt> or
    <tt>-qfixed=132</tt>) to the compiler.
  </li>
  <li>
    Code in C/C++ header files as well as included code in Fortran (either
    using the C preprocessor or the <tt>include</tt> keyword) will currently
    not be instrumented.
  </li>
  <li>
    Support for C++ templates and classes is currently only partially
    implemented.
  </li>
  <li>
    Advanced TAU instrumentation features such as static/dynamic timers, loop,
    I/O and memory instrumentation are not yet supported. Respective entries
    in the selective instrumentation file will be ignored.
  </li>
</ul>

@section user_library_wrapping User Library Wrapping
@seclabel{user_library_wrapping}

<!-- adapted from from src/tools/libwrap-init/README.md Overview -->
User library wrapping enables you to install library wrappers for any
C/C++ library you want.

Without this mechanism, in order to intercept calls to a library, you would
need to either build this library with @scorep or add manual instrumentation
to the application using the library.
Another advantage of user library wrapping is you don't need access to the
source code of the to-be-wrapped library. Headers and library files suffice.

This feature requires @scorep to be configured with libclang.
You can find out whether user library wrapping is enabled via
`scorep-info config-summary` in Section "Score-P (libwrap)".

This section covers how to use already installed wrappers.
Appendix @ref scoreplibwrap explains how to create user library wrappers,
and provides additional details.

<!-- adapted from src/tools/libwrap-init/README.md Workflow for Wrapping a Library Use the Wrapper -->
To find out which user library wrappers are installed call

    $ scorep-info libwrap-summary

It lists all found wrappers, either installed into Score-P's installation
directory or found via the <tt>SCOREP_LIBWRAP_PATH</tt> environment variable.
Optionally you can run

    $ scorep-info libwrap-summary <wrappername>

to show the configuration of a specific wrapper.

You can then use @scorep to link your application in the usual way and
additionally provide `--libwrap=[<wrapmode>:]<wrappername>` to enable library wrapping for
the target library.

Example with only relinking the application:

    $ scorep --libwrap=fftw3 gcc -o main main.o -L$FFTW_LIB -lfftw3

Example with both recompiling and linking the application:

    $ scorep --libwrap=fftw3 --nocompiler gcc -o main -I$FFTW_INC main.c \
        -L$FFTW_LIB -lfftw3

@subsection user_library_wrapping_modes Runtime vs Linktime Wrapping

There exist two ways to wrap calls to the to-be-wrapped (or target-)
library. The main difference lies in when the actual wrapping takes place -
at @emph{linktime} or @emph{runtime}. While they are in essence the same, they differ in
which function calls can be intercepted. Specifically:

<dl>
<dt>`linktime`:</dt>
<dd>
Wraps calls originating from object files that are part of the linker command
line. In addition, calls originating from static libraries are wrapped as well.
The actual technique used is the `-wrap` linker flag.
</dd>
<dt>`runtime`:</dt>
<dd>
Wraps all calls that linktime wrapping would, plus those which
originate from already linked shared objects.
The actual technique used is replacing the original function
of the target library and using `dlopen` and `dlsym` in the
wrapper to open the target library plus finding and calling the
original function.
</dd>
</dl>

You can choose linktime or runtime wrapping manually via the `--libwrap` flag
by prefixing the wrapper name with either `linktime:` or `runtime:`.

@section scorep_link_mode Enforce Linking of Static/Shared @scorep Libraries
@seclabel{scorep_link_mode}

If the @scorep was build with shared libraries and with static libraries,
the instrumenter uses the compiler defaults for linking. E.g., if the compiler
chooses shared libraries by default, the instrumenter will link your application
with the shared Score-P libraries. Furthermore, the linking is affected by
parameters in the original link command. E.g., if your link command contains
a <tt>-Bstatic</tt> flag, afterwards appended @scorep libraries are also linked
statically.

If you want to override the default and enforce linking of static or dynamic
@scorep libraries, you can add the flag <tt>\--static</tt> or <tt>\--dynamic</tt>
for the instrumenter. E.g., a command to enforce static linking can look like:

@verbatim
    scorep --static mpicc foo.c -o foo
@endverbatim

In this case, the linking against the static version of the @scorep libraries
is enforced.

If enforcing static or dynamic linking is not possible on your
system, e.g., because no static/dynamic @scorep libraries are installed,
the instrumenter will abort with an error. You can determine whether
<tt>\--static</tt> or <tt>\--dynamic</tt> is available from the
output of <tt>scorep \--help</tt>. If the <tt>\--static</tt> or
<tt>\--dynamic</tt> flags are not shown, then they are not available.

*/
